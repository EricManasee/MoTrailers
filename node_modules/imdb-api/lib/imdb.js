"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var interfaces_1 = require("./interfaces");
var rp = require("request-promise-native");
var omdbapi = "https://www.omdbapi.com/";
function reqtoqueryobj(req, apikey, page) {
    return {
        apikey: apikey,
        page: page,
        r: "json",
        s: req.name,
        type: req.reqtype,
        y: req.year,
    };
}
var trans_table = {
    Genre: "genres",
    Language: "languages",
    imdbRating: "rating",
    imdbVotes: "votes",
};
var Movie = (function () {
    function Movie(obj) {
        for (var _i = 0, _a = Object.getOwnPropertyNames(obj); _i < _a.length; _i++) {
            var attr = _a[_i];
            if (attr === "Year") {
                this._year_data = obj[attr];
                if (!obj[attr].match(/\d{4}[\-â€“](?:\d{4})?/)) {
                    var val = parseInt(obj[attr], 10);
                    if (isNaN(val)) {
                        throw new TypeError("invalid year");
                    }
                    this[attr.toLowerCase()] = val;
                }
            }
            else if (attr === "Released") {
                var val = new Date(obj[attr]);
                if (isNaN(val.getTime())) {
                    this.released = undefined;
                }
                else {
                    this.released = val;
                }
            }
            else if (attr === "imdbRating") {
                var key = trans_table[attr];
                var val = parseFloat(obj[attr]);
                this[key] = isNaN(val) ? 0 : val;
            }
            else if (trans_table[attr] !== undefined) {
                this[trans_table[attr]] = obj[attr];
            }
            else {
                this[attr.toLowerCase()] = obj[attr];
            }
        }
        this.name = this.title;
        this.series = this.type === "movie" ? false : true;
        this.imdburl = "https://www.imdb.com/title/" + this.imdbid;
    }
    return Movie;
}());
exports.Movie = Movie;
var Episode = (function (_super) {
    __extends(Episode, _super);
    function Episode(obj, season) {
        var _this = _super.call(this, obj) || this;
        _this.season = season;
        if (obj.hasOwnProperty("Episode")) {
            _this.episode = parseInt(obj.Episode, 10);
            if (isNaN(_this.episode)) {
                throw new TypeError("invalid episode");
            }
        }
        return _this;
    }
    return Episode;
}(Movie));
exports.Episode = Episode;
var TVShow = (function (_super) {
    __extends(TVShow, _super);
    function TVShow(obj, opts) {
        var _this = _super.call(this, obj) || this;
        _this._episodes = [];
        var years = _this._year_data.split("-");
        _this.start_year = parseInt(years[0], 10);
        _this.end_year = parseInt(years[1], 10) ? parseInt(years[1], 10) : undefined;
        _this.totalseasons = parseInt(obj.totalSeasons, 10);
        _this.opts = opts;
        return _this;
    }
    TVShow.prototype.episodes = function () {
        if (this._episodes.length !== 0) {
            return Promise.resolve(this._episodes);
        }
        var tvShow = this;
        var funcs = [];
        for (var i = 1; i <= tvShow.totalseasons; i++) {
            var reqopts = {
                json: true,
                qs: {
                    Season: i,
                    apikey: tvShow.opts.apiKey,
                    i: tvShow.imdbid,
                    r: "json",
                },
                timeout: undefined,
                url: omdbapi,
                withCredentials: false,
            };
            if ("timeout" in this.opts) {
                reqopts.timeout = this.opts.timeout;
            }
            funcs.push(rp(reqopts));
        }
        var prom = Promise.all(funcs)
            .then(function (ep_data) {
            var eps = [];
            for (var _i = 0, ep_data_1 = ep_data; _i < ep_data_1.length; _i++) {
                var datum = ep_data_1[_i];
                if (interfaces_1.isError(datum)) {
                    throw new ImdbError(datum.Error);
                }
                var season = parseInt(datum.Season, 10);
                for (var _a = 0, _b = Object.getOwnPropertyNames(datum.Episodes); _a < _b.length; _a++) {
                    var ep = _b[_a];
                    eps.push(new Episode(datum.Episodes[ep], season));
                }
            }
            tvShow._episodes = eps;
            return Promise.resolve(eps);
        });
        return prom;
    };
    return TVShow;
}(Movie));
exports.TVShow = TVShow;
var SearchResult = (function () {
    function SearchResult(obj) {
        for (var _i = 0, _a = Object.getOwnPropertyNames(obj); _i < _a.length; _i++) {
            var attr = _a[_i];
            if (attr === "Year") {
                this[attr.toLowerCase()] = parseInt(obj[attr], 10);
            }
            else {
                this[attr.toLowerCase()] = obj[attr];
            }
        }
        this.name = this.title;
    }
    return SearchResult;
}());
exports.SearchResult = SearchResult;
var SearchResults = (function () {
    function SearchResults(obj, page, opts, req) {
        this.results = [];
        this.page = page;
        this.req = req;
        this.opts = opts;
        for (var _i = 0, _a = Object.getOwnPropertyNames(obj); _i < _a.length; _i++) {
            var attr = _a[_i];
            if (attr === "Search") {
                for (var _b = 0, _c = obj.Search; _b < _c.length; _b++) {
                    var result = _c[_b];
                    this.results.push(new SearchResult(result));
                }
            }
            else if (attr === "totalResults") {
                this[attr.toLowerCase()] = parseInt(obj[attr], 10);
            }
            else {
                this[attr.toLowerCase()] = obj[attr];
            }
        }
    }
    SearchResults.prototype.next = function () {
        return search(this.req, this.opts, this.page + 1);
    };
    return SearchResults;
}());
exports.SearchResults = SearchResults;
var ImdbError = (function () {
    function ImdbError(message) {
        this.message = message;
        this.name = "imdb api error";
    }
    return ImdbError;
}());
exports.ImdbError = ImdbError;
function get(req, opts) {
    try {
        return new Client(opts).get(req);
    }
    catch (e) {
        return Promise.reject(e);
    }
}
exports.get = get;
function search(req, opts, page) {
    return new Client(opts).search(req, page);
}
exports.search = search;
var Client = (function () {
    function Client(opts) {
        if (!opts.hasOwnProperty("apiKey")) {
            throw new ImdbError("Missing api key in opts");
        }
        this.opts = opts;
    }
    Client.prototype.get = function (req, opts) {
        opts = this.merge_opts(opts);
        var qs = {
            apikey: opts.apiKey,
            i: undefined,
            plot: req.short_plot ? "short" : "full",
            r: "json",
            t: undefined,
            y: req.year,
        };
        if (req.name) {
            qs.t = req.name;
        }
        else if (req.id) {
            qs.i = req.id;
        }
        else {
            return Promise.reject(new ImdbError("Missing one of req.id or req.name"));
        }
        var reqopts = {
            json: true,
            qs: qs,
            timeout: undefined,
            url: omdbapi,
            withCredentials: false,
        };
        if ("timeout" in opts) {
            reqopts.timeout = opts.timeout;
        }
        var prom = rp(reqopts).then(function (data) {
            var ret;
            if (interfaces_1.isError(data)) {
                throw new ImdbError(data.Error + ": " + (req.name ? req.name : req.id));
            }
            if (interfaces_1.isMovie(data)) {
                ret = new Movie(data);
            }
            else if (interfaces_1.isTvshow(data)) {
                ret = new TVShow(data, opts);
            }
            else if (interfaces_1.isEpisode(data)) {
                ret = new Episode(data, 30);
            }
            else {
                throw new ImdbError("type: '" + data.Type + "' is not valid");
            }
            return Promise.resolve(ret);
        });
        return prom;
    };
    Client.prototype.search = function (req, page, opts) {
        opts = this.merge_opts(opts);
        if (page === undefined) {
            page = 1;
        }
        var qs = reqtoqueryobj(req, opts.apiKey, page);
        var reqopts = { qs: qs, url: omdbapi, json: true, timeout: undefined, withCredentials: false };
        if ("timeout" in opts) {
            reqopts.timeout = opts.timeout;
        }
        var prom = rp(reqopts).then(function (data) {
            if (interfaces_1.isError(data)) {
                throw new ImdbError(data.Error + ": " + req.name);
            }
            return Promise.resolve(new SearchResults(data, page, opts, req));
        });
        return prom;
    };
    Client.prototype.merge_opts = function (opts) {
        if (opts !== undefined) {
            return Object.assign(__assign({}, this.opts), opts);
        }
        return __assign({}, this.opts);
    };
    return Client;
}());
exports.Client = Client;
//# sourceMappingURL=imdb.js.map